# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_tulipUQ', [dirname(__file__)])
        except ImportError:
            import _tulipUQ
            return _tulipUQ
        if fp is not None:
            try:
                _mod = imp.load_module('_tulipUQ', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _tulipUQ = swig_import_helper()
    del swig_import_helper
else:
    import _tulipUQ
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tulipUQ.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _tulipUQ.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _tulipUQ.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _tulipUQ.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _tulipUQ.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _tulipUQ.SwigPyIterator_equal(self, x)

    def copy(self):
        return _tulipUQ.SwigPyIterator_copy(self)

    def next(self):
        return _tulipUQ.SwigPyIterator_next(self)

    def __next__(self):
        return _tulipUQ.SwigPyIterator___next__(self)

    def previous(self):
        return _tulipUQ.SwigPyIterator_previous(self)

    def advance(self, n):
        return _tulipUQ.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _tulipUQ.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _tulipUQ.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _tulipUQ.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _tulipUQ.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _tulipUQ.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _tulipUQ.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _tulipUQ.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_tulipUQ.atPoly_swigconstant(_tulipUQ)
atPoly = _tulipUQ.atPoly

_tulipUQ.atOrthoPoly_swigconstant(_tulipUQ)
atOrthoPoly = _tulipUQ.atOrthoPoly

_tulipUQ.atMW_swigconstant(_tulipUQ)
atMW = _tulipUQ.atMW
class uq1DApproximant(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uq1DApproximant, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uq1DApproximant, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tulipUQ.delete_uq1DApproximant
    __del__ = lambda self: None

    def exportToTextFile(self, fileName, append=False):
        return _tulipUQ.uq1DApproximant_exportToTextFile(self, fileName, append)

    def importFromTextFile(self, fileName, startFromTop=True, startLine=0):
        return _tulipUQ.uq1DApproximant_importFromTextFile(self, fileName, startFromTop, startLine)

    def normalizeByConstant(self, normValue):
        return _tulipUQ.uq1DApproximant_normalizeByConstant(self, normValue)

    def getExtremes(self, result):
        return _tulipUQ.uq1DApproximant_getExtremes(self, result)

    def evaluate(self, *args):
        return _tulipUQ.uq1DApproximant_evaluate(self, *args)
uq1DApproximant_swigregister = _tulipUQ.uq1DApproximant_swigregister
uq1DApproximant_swigregister(uq1DApproximant)

class uq1DApproximant_SE(uq1DApproximant):
    __swig_setmethods__ = {}
    for _s in [uq1DApproximant]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uq1DApproximant_SE, name, value)
    __swig_getmethods__ = {}
    for _s in [uq1DApproximant]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uq1DApproximant_SE, name)
    __repr__ = _swig_repr
    __swig_setmethods__["approxType"] = _tulipUQ.uq1DApproximant_SE_approxType_set
    __swig_getmethods__["approxType"] = _tulipUQ.uq1DApproximant_SE_approxType_get
    if _newclass:
        approxType = _swig_property(_tulipUQ.uq1DApproximant_SE_approxType_get, _tulipUQ.uq1DApproximant_SE_approxType_set)
    __swig_setmethods__["polyType"] = _tulipUQ.uq1DApproximant_SE_polyType_set
    __swig_getmethods__["polyType"] = _tulipUQ.uq1DApproximant_SE_polyType_get
    if _newclass:
        polyType = _swig_property(_tulipUQ.uq1DApproximant_SE_polyType_get, _tulipUQ.uq1DApproximant_SE_polyType_set)
    __swig_setmethods__["basis"] = _tulipUQ.uq1DApproximant_SE_basis_set
    __swig_getmethods__["basis"] = _tulipUQ.uq1DApproximant_SE_basis_get
    if _newclass:
        basis = _swig_property(_tulipUQ.uq1DApproximant_SE_basis_get, _tulipUQ.uq1DApproximant_SE_basis_set)
    __swig_setmethods__["coeff"] = _tulipUQ.uq1DApproximant_SE_coeff_set
    __swig_getmethods__["coeff"] = _tulipUQ.uq1DApproximant_SE_coeff_get
    if _newclass:
        coeff = _swig_property(_tulipUQ.uq1DApproximant_SE_coeff_get, _tulipUQ.uq1DApproximant_SE_coeff_set)
    __swig_setmethods__["limits"] = _tulipUQ.uq1DApproximant_SE_limits_set
    __swig_getmethods__["limits"] = _tulipUQ.uq1DApproximant_SE_limits_get
    if _newclass:
        limits = _swig_property(_tulipUQ.uq1DApproximant_SE_limits_get, _tulipUQ.uq1DApproximant_SE_limits_set)

    def __init__(self, *args):
        this = _tulipUQ.new_uq1DApproximant_SE(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uq1DApproximant_SE
    __del__ = lambda self: None

    def evaluate(self, XValue):
        return _tulipUQ.uq1DApproximant_SE_evaluate(self, XValue)

    def exportToTextFile(self, fileName, append=False):
        return _tulipUQ.uq1DApproximant_SE_exportToTextFile(self, fileName, append)

    def importFromTextFile(self, fileName, startFromTop=True, startLine=0):
        return _tulipUQ.uq1DApproximant_SE_importFromTextFile(self, fileName, startFromTop, startLine)

    def normalizeByConstant(self, normValue):
        return _tulipUQ.uq1DApproximant_SE_normalizeByConstant(self, normValue)

    def getExtremes(self, result):
        return _tulipUQ.uq1DApproximant_SE_getExtremes(self, result)
uq1DApproximant_SE_swigregister = _tulipUQ.uq1DApproximant_SE_swigregister
uq1DApproximant_SE_swigregister(uq1DApproximant_SE)

class uq1DApproximant_ME(uq1DApproximant):
    __swig_setmethods__ = {}
    for _s in [uq1DApproximant]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uq1DApproximant_ME, name, value)
    __swig_getmethods__ = {}
    for _s in [uq1DApproximant]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uq1DApproximant_ME, name)
    __repr__ = _swig_repr
    __swig_setmethods__["approx"] = _tulipUQ.uq1DApproximant_ME_approx_set
    __swig_getmethods__["approx"] = _tulipUQ.uq1DApproximant_ME_approx_get
    if _newclass:
        approx = _swig_property(_tulipUQ.uq1DApproximant_ME_approx_get, _tulipUQ.uq1DApproximant_ME_approx_set)
    __swig_destroy__ = _tulipUQ.delete_uq1DApproximant_ME
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _tulipUQ.new_uq1DApproximant_ME(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def evaluate(self, XValue):
        return _tulipUQ.uq1DApproximant_ME_evaluate(self, XValue)

    def exportToTextFile(self, fileName, append=False):
        return _tulipUQ.uq1DApproximant_ME_exportToTextFile(self, fileName, append)

    def importFromTextFile(self, fileName, startFromTop=True, startLine=0):
        return _tulipUQ.uq1DApproximant_ME_importFromTextFile(self, fileName, startFromTop, startLine)

    def normalizeByConstant(self, normValue):
        return _tulipUQ.uq1DApproximant_ME_normalizeByConstant(self, normValue)

    def getExtremes(self, result):
        return _tulipUQ.uq1DApproximant_ME_getExtremes(self, result)

    def getElementID(self, value):
        return _tulipUQ.uq1DApproximant_ME_getElementID(self, value)
uq1DApproximant_ME_swigregister = _tulipUQ.uq1DApproximant_ME_swigregister
uq1DApproximant_ME_swigregister(uq1DApproximant_ME)

class uq1DQuadratureRule(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uq1DQuadratureRule, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uq1DQuadratureRule, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_setmethods__["quadOrder"] = _tulipUQ.uq1DQuadratureRule_quadOrder_set
    __swig_getmethods__["quadOrder"] = _tulipUQ.uq1DQuadratureRule_quadOrder_get
    if _newclass:
        quadOrder = _swig_property(_tulipUQ.uq1DQuadratureRule_quadOrder_get, _tulipUQ.uq1DQuadratureRule_quadOrder_set)
    __swig_setmethods__["totalPoints"] = _tulipUQ.uq1DQuadratureRule_totalPoints_set
    __swig_getmethods__["totalPoints"] = _tulipUQ.uq1DQuadratureRule_totalPoints_get
    if _newclass:
        totalPoints = _swig_property(_tulipUQ.uq1DQuadratureRule_totalPoints_get, _tulipUQ.uq1DQuadratureRule_totalPoints_set)
    __swig_setmethods__["supportType"] = _tulipUQ.uq1DQuadratureRule_supportType_set
    __swig_getmethods__["supportType"] = _tulipUQ.uq1DQuadratureRule_supportType_get
    if _newclass:
        supportType = _swig_property(_tulipUQ.uq1DQuadratureRule_supportType_get, _tulipUQ.uq1DQuadratureRule_supportType_set)
    __swig_setmethods__["points"] = _tulipUQ.uq1DQuadratureRule_points_set
    __swig_getmethods__["points"] = _tulipUQ.uq1DQuadratureRule_points_get
    if _newclass:
        points = _swig_property(_tulipUQ.uq1DQuadratureRule_points_get, _tulipUQ.uq1DQuadratureRule_points_set)
    __swig_setmethods__["weights"] = _tulipUQ.uq1DQuadratureRule_weights_set
    __swig_getmethods__["weights"] = _tulipUQ.uq1DQuadratureRule_weights_get
    if _newclass:
        weights = _swig_property(_tulipUQ.uq1DQuadratureRule_weights_get, _tulipUQ.uq1DQuadratureRule_weights_set)
    __swig_destroy__ = _tulipUQ.delete_uq1DQuadratureRule
    __del__ = lambda self: None

    def getTotalPoints(self):
        return _tulipUQ.uq1DQuadratureRule_getTotalPoints(self)

    def getPoints(self):
        return _tulipUQ.uq1DQuadratureRule_getPoints(self)

    def getWeights(self):
        return _tulipUQ.uq1DQuadratureRule_getWeights(self)

    def printToFile(self, fileName):
        return _tulipUQ.uq1DQuadratureRule_printToFile(self, fileName)

    def printToScreen(self):
        return _tulipUQ.uq1DQuadratureRule_printToScreen(self)

    def generatePointsAndWeights(self):
        return _tulipUQ.uq1DQuadratureRule_generatePointsAndWeights(self)
uq1DQuadratureRule_swigregister = _tulipUQ.uq1DQuadratureRule_swigregister
uq1DQuadratureRule_swigregister(uq1DQuadratureRule)

class uq1DQuadratureRule_Regular(uq1DQuadratureRule):
    __swig_setmethods__ = {}
    for _s in [uq1DQuadratureRule]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uq1DQuadratureRule_Regular, name, value)
    __swig_getmethods__ = {}
    for _s in [uq1DQuadratureRule]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uq1DQuadratureRule_Regular, name)
    __repr__ = _swig_repr

    def __init__(self, order, suppType):
        this = _tulipUQ.new_uq1DQuadratureRule_Regular(order, suppType)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uq1DQuadratureRule_Regular
    __del__ = lambda self: None

    def generatePointsAndWeights(self):
        return _tulipUQ.uq1DQuadratureRule_Regular_generatePointsAndWeights(self)
uq1DQuadratureRule_Regular_swigregister = _tulipUQ.uq1DQuadratureRule_Regular_swigregister
uq1DQuadratureRule_Regular_swigregister(uq1DQuadratureRule_Regular)

class uq1DQuadratureRule_CC(uq1DQuadratureRule):
    __swig_setmethods__ = {}
    for _s in [uq1DQuadratureRule]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uq1DQuadratureRule_CC, name, value)
    __swig_getmethods__ = {}
    for _s in [uq1DQuadratureRule]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uq1DQuadratureRule_CC, name)
    __repr__ = _swig_repr

    def __init__(self, quadOrder, suppType):
        this = _tulipUQ.new_uq1DQuadratureRule_CC(quadOrder, suppType)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uq1DQuadratureRule_CC
    __del__ = lambda self: None

    def generatePointsAndWeights(self):
        return _tulipUQ.uq1DQuadratureRule_CC_generatePointsAndWeights(self)
uq1DQuadratureRule_CC_swigregister = _tulipUQ.uq1DQuadratureRule_CC_swigregister
uq1DQuadratureRule_CC_swigregister(uq1DQuadratureRule_CC)

class uq1DQuadratureRule_CCDouble(uq1DQuadratureRule):
    __swig_setmethods__ = {}
    for _s in [uq1DQuadratureRule]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uq1DQuadratureRule_CCDouble, name, value)
    __swig_getmethods__ = {}
    for _s in [uq1DQuadratureRule]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uq1DQuadratureRule_CCDouble, name)
    __repr__ = _swig_repr

    def __init__(self, quadOrder, suppType):
        this = _tulipUQ.new_uq1DQuadratureRule_CCDouble(quadOrder, suppType)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uq1DQuadratureRule_CCDouble
    __del__ = lambda self: None

    def generatePointsAndWeights(self):
        return _tulipUQ.uq1DQuadratureRule_CCDouble_generatePointsAndWeights(self)
uq1DQuadratureRule_CCDouble_swigregister = _tulipUQ.uq1DQuadratureRule_CCDouble_swigregister
uq1DQuadratureRule_CCDouble_swigregister(uq1DQuadratureRule_CCDouble)

class uqAlgorithm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqAlgorithm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uqAlgorithm, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _tulipUQ.new_uqAlgorithm()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqAlgorithm
    __del__ = lambda self: None
uqAlgorithm_swigregister = _tulipUQ.uqAlgorithm_swigregister
uqAlgorithm_swigregister(uqAlgorithm)

class rvmOptionRecord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, rvmOptionRecord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, rvmOptionRecord, name)
    __repr__ = _swig_repr
    __swig_setmethods__["estimateNoise"] = _tulipUQ.rvmOptionRecord_estimateNoise_set
    __swig_getmethods__["estimateNoise"] = _tulipUQ.rvmOptionRecord_estimateNoise_get
    if _newclass:
        estimateNoise = _swig_property(_tulipUQ.rvmOptionRecord_estimateNoise_get, _tulipUQ.rvmOptionRecord_estimateNoise_set)
    __swig_setmethods__["printProgressToScreen"] = _tulipUQ.rvmOptionRecord_printProgressToScreen_set
    __swig_getmethods__["printProgressToScreen"] = _tulipUQ.rvmOptionRecord_printProgressToScreen_get
    if _newclass:
        printProgressToScreen = _swig_property(_tulipUQ.rvmOptionRecord_printProgressToScreen_get, _tulipUQ.rvmOptionRecord_printProgressToScreen_set)
    __swig_setmethods__["printDBGMessages"] = _tulipUQ.rvmOptionRecord_printDBGMessages_set
    __swig_getmethods__["printDBGMessages"] = _tulipUQ.rvmOptionRecord_printDBGMessages_get
    if _newclass:
        printDBGMessages = _swig_property(_tulipUQ.rvmOptionRecord_printDBGMessages_get, _tulipUQ.rvmOptionRecord_printDBGMessages_set)
    __swig_setmethods__["maxIteration"] = _tulipUQ.rvmOptionRecord_maxIteration_set
    __swig_getmethods__["maxIteration"] = _tulipUQ.rvmOptionRecord_maxIteration_get
    if _newclass:
        maxIteration = _swig_property(_tulipUQ.rvmOptionRecord_maxIteration_get, _tulipUQ.rvmOptionRecord_maxIteration_set)
    __swig_setmethods__["maxBetaIterations"] = _tulipUQ.rvmOptionRecord_maxBetaIterations_set
    __swig_getmethods__["maxBetaIterations"] = _tulipUQ.rvmOptionRecord_maxBetaIterations_get
    if _newclass:
        maxBetaIterations = _swig_property(_tulipUQ.rvmOptionRecord_maxBetaIterations_get, _tulipUQ.rvmOptionRecord_maxBetaIterations_set)

    def __init__(self):
        this = _tulipUQ.new_rvmOptionRecord()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_rvmOptionRecord
    __del__ = lambda self: None
rvmOptionRecord_swigregister = _tulipUQ.rvmOptionRecord_swigregister
rvmOptionRecord_swigregister(rvmOptionRecord)
cvar = _tulipUQ.cvar
kActionReestimate = cvar.kActionReestimate
kActionAdd = cvar.kActionAdd
kActionDelete = cvar.kActionDelete
kActionFinish = cvar.kActionFinish
kActionSkipForAlignment = cvar.kActionSkipForAlignment

class uqAlgorithmBCS(uqAlgorithm):
    __swig_setmethods__ = {}
    for _s in [uqAlgorithm]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqAlgorithmBCS, name, value)
    __swig_getmethods__ = {}
    for _s in [uqAlgorithm]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uqAlgorithmBCS, name)
    __repr__ = _swig_repr
    __swig_setmethods__["opts"] = _tulipUQ.uqAlgorithmBCS_opts_set
    __swig_getmethods__["opts"] = _tulipUQ.uqAlgorithmBCS_opts_get
    if _newclass:
        opts = _swig_property(_tulipUQ.uqAlgorithmBCS_opts_get, _tulipUQ.uqAlgorithmBCS_opts_set)

    def __init__(self):
        this = _tulipUQ.new_uqAlgorithmBCS()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def run(self, sample_num, par_num, yValues, basisMat, coeffs, coeffsCov, noiseEstimate):
        return _tulipUQ.uqAlgorithmBCS_run(self, sample_num, par_num, yValues, basisMat, coeffs, coeffsCov, noiseEstimate)
    __swig_destroy__ = _tulipUQ.delete_uqAlgorithmBCS
    __del__ = lambda self: None
uqAlgorithmBCS_swigregister = _tulipUQ.uqAlgorithmBCS_swigregister
uqAlgorithmBCS_swigregister(uqAlgorithmBCS)

class uqBasis(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqBasis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uqBasis, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_setmethods__["basisOrder"] = _tulipUQ.uqBasis_basisOrder_set
    __swig_getmethods__["basisOrder"] = _tulipUQ.uqBasis_basisOrder_get
    if _newclass:
        basisOrder = _swig_property(_tulipUQ.uqBasis_basisOrder_get, _tulipUQ.uqBasis_basisOrder_set)
    __swig_setmethods__["quadratureOrder"] = _tulipUQ.uqBasis_quadratureOrder_set
    __swig_getmethods__["quadratureOrder"] = _tulipUQ.uqBasis_quadratureOrder_get
    if _newclass:
        quadratureOrder = _swig_property(_tulipUQ.uqBasis_quadratureOrder_get, _tulipUQ.uqBasis_quadratureOrder_set)
    __swig_setmethods__["probabilityMeasure"] = _tulipUQ.uqBasis_probabilityMeasure_set
    __swig_getmethods__["probabilityMeasure"] = _tulipUQ.uqBasis_probabilityMeasure_get
    if _newclass:
        probabilityMeasure = _swig_property(_tulipUQ.uqBasis_probabilityMeasure_get, _tulipUQ.uqBasis_probabilityMeasure_set)
    __swig_destroy__ = _tulipUQ.delete_uqBasis
    __del__ = lambda self: None

    def getPolynomialType(self):
        return _tulipUQ.uqBasis_getPolynomialType(self)

    def evaluate(self, XValue, order):
        return _tulipUQ.uqBasis_evaluate(self, XValue, order)
uqBasis_swigregister = _tulipUQ.uqBasis_swigregister
uqBasis_swigregister(uqBasis)

class uqPolyBasis(uqBasis):
    __swig_setmethods__ = {}
    for _s in [uqBasis]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqPolyBasis, name, value)
    __swig_getmethods__ = {}
    for _s in [uqBasis]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uqPolyBasis, name)
    __repr__ = _swig_repr
    __swig_setmethods__["polyType"] = _tulipUQ.uqPolyBasis_polyType_set
    __swig_getmethods__["polyType"] = _tulipUQ.uqPolyBasis_polyType_get
    if _newclass:
        polyType = _swig_property(_tulipUQ.uqPolyBasis_polyType_get, _tulipUQ.uqPolyBasis_polyType_set)

    def __init__(self, *args):
        this = _tulipUQ.new_uqPolyBasis(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqPolyBasis
    __del__ = lambda self: None

    def getPolynomialType(self):
        return _tulipUQ.uqPolyBasis_getPolynomialType(self)

    def evaluate(self, XValue, order):
        return _tulipUQ.uqPolyBasis_evaluate(self, XValue, order)
uqPolyBasis_swigregister = _tulipUQ.uqPolyBasis_swigregister
uqPolyBasis_swigregister(uqPolyBasis)

class uqOrthoPolyBasis(uqBasis):
    __swig_setmethods__ = {}
    for _s in [uqBasis]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqOrthoPolyBasis, name, value)
    __swig_getmethods__ = {}
    for _s in [uqBasis]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uqOrthoPolyBasis, name)
    __repr__ = _swig_repr
    __swig_setmethods__["alphaCoeff"] = _tulipUQ.uqOrthoPolyBasis_alphaCoeff_set
    __swig_getmethods__["alphaCoeff"] = _tulipUQ.uqOrthoPolyBasis_alphaCoeff_get
    if _newclass:
        alphaCoeff = _swig_property(_tulipUQ.uqOrthoPolyBasis_alphaCoeff_get, _tulipUQ.uqOrthoPolyBasis_alphaCoeff_set)
    __swig_setmethods__["betaCoeff"] = _tulipUQ.uqOrthoPolyBasis_betaCoeff_set
    __swig_getmethods__["betaCoeff"] = _tulipUQ.uqOrthoPolyBasis_betaCoeff_get
    if _newclass:
        betaCoeff = _swig_property(_tulipUQ.uqOrthoPolyBasis_betaCoeff_get, _tulipUQ.uqOrthoPolyBasis_betaCoeff_set)
    __swig_setmethods__["normCoeff"] = _tulipUQ.uqOrthoPolyBasis_normCoeff_set
    __swig_getmethods__["normCoeff"] = _tulipUQ.uqOrthoPolyBasis_normCoeff_get
    if _newclass:
        normCoeff = _swig_property(_tulipUQ.uqOrthoPolyBasis_normCoeff_get, _tulipUQ.uqOrthoPolyBasis_normCoeff_set)

    def __init__(self, order, level, measureAtQuadPoints):
        this = _tulipUQ.new_uqOrthoPolyBasis(order, level, measureAtQuadPoints)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqOrthoPolyBasis
    __del__ = lambda self: None

    def buildRecursiveCoefficients(self):
        return _tulipUQ.uqOrthoPolyBasis_buildRecursiveCoefficients(self)

    def getPolynomialType(self):
        return _tulipUQ.uqOrthoPolyBasis_getPolynomialType(self)

    def evaluate(self, XValue, order):
        return _tulipUQ.uqOrthoPolyBasis_evaluate(self, XValue, order)
uqOrthoPolyBasis_swigregister = _tulipUQ.uqOrthoPolyBasis_swigregister
uqOrthoPolyBasis_swigregister(uqOrthoPolyBasis)

class uqMWBasis(uqBasis):
    __swig_setmethods__ = {}
    for _s in [uqBasis]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqMWBasis, name, value)
    __swig_getmethods__ = {}
    for _s in [uqBasis]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uqMWBasis, name)
    __repr__ = _swig_repr
    __swig_setmethods__["isMeasureUniform"] = _tulipUQ.uqMWBasis_isMeasureUniform_set
    __swig_getmethods__["isMeasureUniform"] = _tulipUQ.uqMWBasis_isMeasureUniform_get
    if _newclass:
        isMeasureUniform = _swig_property(_tulipUQ.uqMWBasis_isMeasureUniform_get, _tulipUQ.uqMWBasis_isMeasureUniform_set)
    __swig_setmethods__["monoCoeffs"] = _tulipUQ.uqMWBasis_monoCoeffs_set
    __swig_getmethods__["monoCoeffs"] = _tulipUQ.uqMWBasis_monoCoeffs_get
    if _newclass:
        monoCoeffs = _swig_property(_tulipUQ.uqMWBasis_monoCoeffs_get, _tulipUQ.uqMWBasis_monoCoeffs_set)
    __swig_setmethods__["refPoly"] = _tulipUQ.uqMWBasis_refPoly_set
    __swig_getmethods__["refPoly"] = _tulipUQ.uqMWBasis_refPoly_get
    if _newclass:
        refPoly = _swig_property(_tulipUQ.uqMWBasis_refPoly_get, _tulipUQ.uqMWBasis_refPoly_set)
    __swig_setmethods__["productMat"] = _tulipUQ.uqMWBasis_productMat_set
    __swig_getmethods__["productMat"] = _tulipUQ.uqMWBasis_productMat_get
    if _newclass:
        productMat = _swig_property(_tulipUQ.uqMWBasis_productMat_get, _tulipUQ.uqMWBasis_productMat_set)
    __swig_setmethods__["gsCoeffs"] = _tulipUQ.uqMWBasis_gsCoeffs_set
    __swig_getmethods__["gsCoeffs"] = _tulipUQ.uqMWBasis_gsCoeffs_get
    if _newclass:
        gsCoeffs = _swig_property(_tulipUQ.uqMWBasis_gsCoeffs_get, _tulipUQ.uqMWBasis_gsCoeffs_set)
    __swig_setmethods__["normCoeffs"] = _tulipUQ.uqMWBasis_normCoeffs_set
    __swig_getmethods__["normCoeffs"] = _tulipUQ.uqMWBasis_normCoeffs_get
    if _newclass:
        normCoeffs = _swig_property(_tulipUQ.uqMWBasis_normCoeffs_get, _tulipUQ.uqMWBasis_normCoeffs_set)
    __swig_setmethods__["orthoPoly"] = _tulipUQ.uqMWBasis_orthoPoly_set
    __swig_getmethods__["orthoPoly"] = _tulipUQ.uqMWBasis_orthoPoly_get
    if _newclass:
        orthoPoly = _swig_property(_tulipUQ.uqMWBasis_orthoPoly_get, _tulipUQ.uqMWBasis_orthoPoly_set)

    def __init__(self, *args):
        this = _tulipUQ.new_uqMWBasis(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqMWBasis
    __del__ = lambda self: None

    def AllocateMWCoefficients(self):
        return _tulipUQ.uqMWBasis_AllocateMWCoefficients(self)

    def formUniformMeasure(self, quadOrder):
        return _tulipUQ.uqMWBasis_formUniformMeasure(self, quadOrder)

    def FormMultiWaveletCoeffs(self):
        return _tulipUQ.uqMWBasis_FormMultiWaveletCoeffs(self)

    def EvalMS(self, XValue, scaleIndex, shiftIndex, polyOrderIndex):
        return _tulipUQ.uqMWBasis_EvalMS(self, XValue, scaleIndex, shiftIndex, polyOrderIndex)

    def EvalMotherMW(self, XValue, mwIndex):
        return _tulipUQ.uqMWBasis_EvalMotherMW(self, XValue, mwIndex)

    def EvalMW(self, XValue, scaleIndex, shiftIndex, polyOrderIndex):
        return _tulipUQ.uqMWBasis_EvalMW(self, XValue, scaleIndex, shiftIndex, polyOrderIndex)

    def EvalExactMotherMW(self, XValue, polyOrder, mwOrder):
        return _tulipUQ.uqMWBasis_EvalExactMotherMW(self, XValue, polyOrder, mwOrder)

    def EvalSingleExactMW(self, XValue, scaleIndex, shiftIndex, polyOrder, mwOrder):
        return _tulipUQ.uqMWBasis_EvalSingleExactMW(self, XValue, scaleIndex, shiftIndex, polyOrder, mwOrder)

    def getPolynomialType(self):
        return _tulipUQ.uqMWBasis_getPolynomialType(self)

    def evaluate(self, XValue, order):
        return _tulipUQ.uqMWBasis_evaluate(self, XValue, order)
uqMWBasis_swigregister = _tulipUQ.uqMWBasis_swigregister
uqMWBasis_swigregister(uqMWBasis)

class uqMultiIndex(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqMultiIndex, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uqMultiIndex, name)
    __repr__ = _swig_repr

    def __init__(self, dim, order, miType):
        this = _tulipUQ.new_uqMultiIndex(dim, order, miType)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getTotalBasis(self):
        return _tulipUQ.uqMultiIndex_getTotalBasis(self)

    def __call__(self, nRow, nCol):
        return _tulipUQ.uqMultiIndex___call__(self, nRow, nCol)

    def contains(self, variable, component):
        return _tulipUQ.uqMultiIndex_contains(self, variable, component)

    def containsOnly(self, variable, component):
        return _tulipUQ.uqMultiIndex_containsOnly(self, variable, component)

    def printToFile(self, outMatFile, printTitle):
        return _tulipUQ.uqMultiIndex_printToFile(self, outMatFile, printTitle)
    __swig_destroy__ = _tulipUQ.delete_uqMultiIndex
    __del__ = lambda self: None
uqMultiIndex_swigregister = _tulipUQ.uqMultiIndex_swigregister
uqMultiIndex_swigregister(uqMultiIndex)

class uqMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uqMatrix, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _tulipUQ.new_uqMatrix()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqMatrix
    __del__ = lambda self: None

    def getRowCount(self):
        return _tulipUQ.uqMatrix_getRowCount(self)

    def getColCount(self):
        return _tulipUQ.uqMatrix_getColCount(self)

    def getMatrix(self):
        return _tulipUQ.uqMatrix_getMatrix(self)

    def getMatrixAt(self, row, col):
        return _tulipUQ.uqMatrix_getMatrixAt(self, row, col)

    def setRowCount(self, rc):
        return _tulipUQ.uqMatrix_setRowCount(self, rc)

    def setColCount(self, cc):
        return _tulipUQ.uqMatrix_setColCount(self, cc)

    def __call__(self, nRow, nCol):
        return _tulipUQ.uqMatrix___call__(self, nRow, nCol)

    def applyTo(self, coeff):
        return _tulipUQ.uqMatrix_applyTo(self, coeff)

    def setColumnToZero(self, colId):
        return _tulipUQ.uqMatrix_setColumnToZero(self, colId)

    def removeColumn(self, colId):
        return _tulipUQ.uqMatrix_removeColumn(self, colId)

    def printToFile(self, outMatFile, printTitle):
        return _tulipUQ.uqMatrix_printToFile(self, outMatFile, printTitle)
uqMatrix_swigregister = _tulipUQ.uqMatrix_swigregister
uqMatrix_swigregister(uqMatrix)

class uqPolyMatrix(uqMatrix):
    __swig_setmethods__ = {}
    for _s in [uqMatrix]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqPolyMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [uqMatrix]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uqPolyMatrix, name)
    __repr__ = _swig_repr

    def __init__(self, xValues, maxOrder, polyType, completeOrderType):
        this = _tulipUQ.new_uqPolyMatrix(xValues, maxOrder, polyType, completeOrderType)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqPolyMatrix
    __del__ = lambda self: None
uqPolyMatrix_swigregister = _tulipUQ.uqPolyMatrix_swigregister
uqPolyMatrix_swigregister(uqPolyMatrix)

class uqMWMatrix(uqMatrix):
    __swig_setmethods__ = {}
    for _s in [uqMatrix]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqMWMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [uqMatrix]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uqMWMatrix, name)
    __repr__ = _swig_repr
    __swig_setmethods__["scaleIdx"] = _tulipUQ.uqMWMatrix_scaleIdx_set
    __swig_getmethods__["scaleIdx"] = _tulipUQ.uqMWMatrix_scaleIdx_get
    if _newclass:
        scaleIdx = _swig_property(_tulipUQ.uqMWMatrix_scaleIdx_get, _tulipUQ.uqMWMatrix_scaleIdx_set)
    __swig_setmethods__["shiftIdx"] = _tulipUQ.uqMWMatrix_shiftIdx_set
    __swig_getmethods__["shiftIdx"] = _tulipUQ.uqMWMatrix_shiftIdx_get
    if _newclass:
        shiftIdx = _swig_property(_tulipUQ.uqMWMatrix_shiftIdx_get, _tulipUQ.uqMWMatrix_shiftIdx_set)
    __swig_setmethods__["multiIdx"] = _tulipUQ.uqMWMatrix_multiIdx_set
    __swig_getmethods__["multiIdx"] = _tulipUQ.uqMWMatrix_multiIdx_get
    if _newclass:
        multiIdx = _swig_property(_tulipUQ.uqMWMatrix_multiIdx_get, _tulipUQ.uqMWMatrix_multiIdx_set)
    __swig_setmethods__["orderIdx"] = _tulipUQ.uqMWMatrix_orderIdx_set
    __swig_getmethods__["orderIdx"] = _tulipUQ.uqMWMatrix_orderIdx_get
    if _newclass:
        orderIdx = _swig_property(_tulipUQ.uqMWMatrix_orderIdx_get, _tulipUQ.uqMWMatrix_orderIdx_set)
    __swig_setmethods__["isMW"] = _tulipUQ.uqMWMatrix_isMW_set
    __swig_getmethods__["isMW"] = _tulipUQ.uqMWMatrix_isMW_get
    if _newclass:
        isMW = _swig_property(_tulipUQ.uqMWMatrix_isMW_get, _tulipUQ.uqMWMatrix_isMW_set)
    __swig_setmethods__["multiIndex"] = _tulipUQ.uqMWMatrix_multiIndex_set
    __swig_getmethods__["multiIndex"] = _tulipUQ.uqMWMatrix_multiIndex_get
    if _newclass:
        multiIndex = _swig_property(_tulipUQ.uqMWMatrix_multiIndex_get, _tulipUQ.uqMWMatrix_multiIndex_set)
    __swig_setmethods__["num_basis"] = _tulipUQ.uqMWMatrix_num_basis_set
    __swig_getmethods__["num_basis"] = _tulipUQ.uqMWMatrix_num_basis_get
    if _newclass:
        num_basis = _swig_property(_tulipUQ.uqMWMatrix_num_basis_get, _tulipUQ.uqMWMatrix_num_basis_set)

    def __init__(self, maxOrder, XValues, addLegendrePoly, addMW, useBinaryPartitions, mwMatType, mwMatIncludeNullColumns, useExactMW, mwQuadOrder, measure, maxColumns, maxDetailLevel):
        this = _tulipUQ.new_uqMWMatrix(maxOrder, XValues, addLegendrePoly, addMW, useBinaryPartitions, mwMatType, mwMatIncludeNullColumns, useExactMW, mwQuadOrder, measure, maxColumns, maxDetailLevel)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqMWMatrix
    __del__ = lambda self: None
uqMWMatrix_swigregister = _tulipUQ.uqMWMatrix_swigregister
uqMWMatrix_swigregister(uqMWMatrix)
kMWFixedMaxDetailLevel = cvar.kMWFixedMaxDetailLevel
kMWFixedColumns = cvar.kMWFixedColumns

class uqPartition(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqPartition, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uqPartition, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _tulipUQ.new_uqPartition()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqPartition
    __del__ = lambda self: None
uqPartition_swigregister = _tulipUQ.uqPartition_swigregister
uqPartition_swigregister(uqPartition)

class uqPartitionNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqPartitionNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uqPartitionNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _tulipUQ.new_uqPartitionNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getScalar(self):
        return _tulipUQ.uqPartitionNode_getScalar(self)

    def setScalar(self, value):
        return _tulipUQ.uqPartitionNode_setScalar(self, value)

    def getInteger(self):
        return _tulipUQ.uqPartitionNode_getInteger(self)

    def setInteger(self, value):
        return _tulipUQ.uqPartitionNode_setInteger(self, value)

    def hasConverged(self):
        return _tulipUQ.uqPartitionNode_hasConverged(self)

    def setConvergence(self, conv):
        return _tulipUQ.uqPartitionNode_setConvergence(self, conv)

    def getStats(self, idx):
        return _tulipUQ.uqPartitionNode_getStats(self, idx)

    def setStats(self, idx, val):
        return _tulipUQ.uqPartitionNode_setStats(self, idx, val)

    def setPartitionErrorMetrics(self, values, indexes):
        return _tulipUQ.uqPartitionNode_setPartitionErrorMetrics(self, values, indexes)

    def getPartitionErrorMetrics(self, values, indexes):
        return _tulipUQ.uqPartitionNode_getPartitionErrorMetrics(self, values, indexes)

    def setChaosCoefficients(self, coeffs):
        return _tulipUQ.uqPartitionNode_setChaosCoefficients(self, coeffs)

    def getChaosCoefficients(self, coeffs):
        return _tulipUQ.uqPartitionNode_getChaosCoefficients(self, coeffs)

    def getMeasure(self, currMeasure):
        return _tulipUQ.uqPartitionNode_getMeasure(self, currMeasure)

    def setMeasure(self, currMeasure):
        return _tulipUQ.uqPartitionNode_setMeasure(self, currMeasure)

    def getMultiIndex(self, mi):
        return _tulipUQ.uqPartitionNode_getMultiIndex(self, mi)

    def setMultiIndex(self, mi):
        return _tulipUQ.uqPartitionNode_setMultiIndex(self, mi)

    def getMSTotBasis(self, msBasis):
        return _tulipUQ.uqPartitionNode_getMSTotBasis(self, msBasis)

    def setMSTotBasis(self, msBasis):
        return _tulipUQ.uqPartitionNode_setMSTotBasis(self, msBasis)

    def getMWQuadOrder(self, mwQuadOrder):
        return _tulipUQ.uqPartitionNode_getMWQuadOrder(self, mwQuadOrder)

    def setMWQuadOrder(self, mwQuadOrder):
        return _tulipUQ.uqPartitionNode_setMWQuadOrder(self, mwQuadOrder)

    def getResidualNorm(self):
        return _tulipUQ.uqPartitionNode_getResidualNorm(self)

    def setResidualNorm(self, resNorm):
        return _tulipUQ.uqPartitionNode_setResidualNorm(self, resNorm)

    def getHasZeroSamples(self):
        return _tulipUQ.uqPartitionNode_getHasZeroSamples(self)

    def setHasZeroSamples(self, flag):
        return _tulipUQ.uqPartitionNode_setHasZeroSamples(self, flag)

    def getQuasiRandomSampleId(self):
        return _tulipUQ.uqPartitionNode_getQuasiRandomSampleId(self)

    def setQuasiRandomSampleId(self, maxId):
        return _tulipUQ.uqPartitionNode_setQuasiRandomSampleId(self, maxId)

    def getLimits(self):
        return _tulipUQ.uqPartitionNode_getLimits(self)

    def countSamplesOnPartition(self, samples):
        return _tulipUQ.uqPartitionNode_countSamplesOnPartition(self, samples)

    def getMinSize(self):
        return _tulipUQ.uqPartitionNode_getMinSize(self)

    def getMaxSizeAndDimension(self, maxPartSize, dimMaxSize):
        return _tulipUQ.uqPartitionNode_getMaxSizeAndDimension(self, maxPartSize, dimMaxSize)

    def getVolume(self):
        return _tulipUQ.uqPartitionNode_getVolume(self)

    def setVolume(self, vol):
        return _tulipUQ.uqPartitionNode_setVolume(self, vol)

    def getLeft(self):
        return _tulipUQ.uqPartitionNode_getLeft(self)

    def getRight(self):
        return _tulipUQ.uqPartitionNode_getRight(self)

    def refine(self, dimToRefine):
        return _tulipUQ.uqPartitionNode_refine(self, dimToRefine)
    __swig_destroy__ = _tulipUQ.delete_uqPartitionNode
    __del__ = lambda self: None
uqPartitionNode_swigregister = _tulipUQ.uqPartitionNode_swigregister
uqPartitionNode_swigregister(uqPartitionNode)

class uqPartitionBinaryTree(uqPartition):
    __swig_setmethods__ = {}
    for _s in [uqPartition]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqPartitionBinaryTree, name, value)
    __swig_getmethods__ = {}
    for _s in [uqPartition]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uqPartitionBinaryTree, name)
    __repr__ = _swig_repr

    def __init__(self, samples):
        this = _tulipUQ.new_uqPartitionBinaryTree(samples)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getAllNodes(self, index):
        return _tulipUQ.uqPartitionBinaryTree_getAllNodes(self, index)

    def AddToAllNodes(self, node):
        return _tulipUQ.uqPartitionBinaryTree_AddToAllNodes(self, node)

    def getLeafCount(self):
        return _tulipUQ.uqPartitionBinaryTree_getLeafCount(self)

    def getLeafIndex(self):
        return _tulipUQ.uqPartitionBinaryTree_getLeafIndex(self)

    def printToScreen(self):
        return _tulipUQ.uqPartitionBinaryTree_printToScreen(self)

    def printLeavesToFile(self, outFileName):
        return _tulipUQ.uqPartitionBinaryTree_printLeavesToFile(self, outFileName)
    __swig_destroy__ = _tulipUQ.delete_uqPartitionBinaryTree
    __del__ = lambda self: None
uqPartitionBinaryTree_swigregister = _tulipUQ.uqPartitionBinaryTree_swigregister
uqPartitionBinaryTree_swigregister(uqPartitionBinaryTree)

class uqPDF(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqPDF, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uqPDF, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _tulipUQ.new_uqPDF()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqPDF
    __del__ = lambda self: None

    def evaluate(self, XValue):
        return _tulipUQ.uqPDF_evaluate(self, XValue)
uqPDF_swigregister = _tulipUQ.uqPDF_swigregister
uqPDF_swigregister(uqPDF)

class uqGaussianPDF(uqPDF):
    __swig_setmethods__ = {}
    for _s in [uqPDF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqGaussianPDF, name, value)
    __swig_getmethods__ = {}
    for _s in [uqPDF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uqGaussianPDF, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mean"] = _tulipUQ.uqGaussianPDF_mean_set
    __swig_getmethods__["mean"] = _tulipUQ.uqGaussianPDF_mean_get
    if _newclass:
        mean = _swig_property(_tulipUQ.uqGaussianPDF_mean_get, _tulipUQ.uqGaussianPDF_mean_set)
    __swig_setmethods__["stdev"] = _tulipUQ.uqGaussianPDF_stdev_set
    __swig_getmethods__["stdev"] = _tulipUQ.uqGaussianPDF_stdev_get
    if _newclass:
        stdev = _swig_property(_tulipUQ.uqGaussianPDF_stdev_get, _tulipUQ.uqGaussianPDF_stdev_set)

    def __init__(self, mean, stdev):
        this = _tulipUQ.new_uqGaussianPDF(mean, stdev)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqGaussianPDF
    __del__ = lambda self: None

    def evaluate(self, XValue):
        return _tulipUQ.uqGaussianPDF_evaluate(self, XValue)
uqGaussianPDF_swigregister = _tulipUQ.uqGaussianPDF_swigregister
uqGaussianPDF_swigregister(uqGaussianPDF)

class uqTruncatedGaussianPDF(uqGaussianPDF):
    __swig_setmethods__ = {}
    for _s in [uqGaussianPDF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqTruncatedGaussianPDF, name, value)
    __swig_getmethods__ = {}
    for _s in [uqGaussianPDF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uqTruncatedGaussianPDF, name)
    __repr__ = _swig_repr
    __swig_setmethods__["truncSigma"] = _tulipUQ.uqTruncatedGaussianPDF_truncSigma_set
    __swig_getmethods__["truncSigma"] = _tulipUQ.uqTruncatedGaussianPDF_truncSigma_get
    if _newclass:
        truncSigma = _swig_property(_tulipUQ.uqTruncatedGaussianPDF_truncSigma_get, _tulipUQ.uqTruncatedGaussianPDF_truncSigma_set)

    def __init__(self, mean, stdev, trunc):
        this = _tulipUQ.new_uqTruncatedGaussianPDF(mean, stdev, trunc)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqTruncatedGaussianPDF
    __del__ = lambda self: None

    def evaluate(self, XValue):
        return _tulipUQ.uqTruncatedGaussianPDF_evaluate(self, XValue)
uqTruncatedGaussianPDF_swigregister = _tulipUQ.uqTruncatedGaussianPDF_swigregister
uqTruncatedGaussianPDF_swigregister(uqTruncatedGaussianPDF)

class uqRescaledTruncatedGaussianPDF(uqTruncatedGaussianPDF):
    __swig_setmethods__ = {}
    for _s in [uqTruncatedGaussianPDF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqRescaledTruncatedGaussianPDF, name, value)
    __swig_getmethods__ = {}
    for _s in [uqTruncatedGaussianPDF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uqRescaledTruncatedGaussianPDF, name)
    __repr__ = _swig_repr
    __swig_setmethods__["truncFactor"] = _tulipUQ.uqRescaledTruncatedGaussianPDF_truncFactor_set
    __swig_getmethods__["truncFactor"] = _tulipUQ.uqRescaledTruncatedGaussianPDF_truncFactor_get
    if _newclass:
        truncFactor = _swig_property(_tulipUQ.uqRescaledTruncatedGaussianPDF_truncFactor_get, _tulipUQ.uqRescaledTruncatedGaussianPDF_truncFactor_set)

    def __init__(self, truncFactor):
        this = _tulipUQ.new_uqRescaledTruncatedGaussianPDF(truncFactor)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqRescaledTruncatedGaussianPDF
    __del__ = lambda self: None

    def evaluate(self, XValue):
        return _tulipUQ.uqRescaledTruncatedGaussianPDF_evaluate(self, XValue)
uqRescaledTruncatedGaussianPDF_swigregister = _tulipUQ.uqRescaledTruncatedGaussianPDF_swigregister
uqRescaledTruncatedGaussianPDF_swigregister(uqRescaledTruncatedGaussianPDF)


_tulipUQ.rsHalton_swigconstant(_tulipUQ)
rsHalton = _tulipUQ.rsHalton

_tulipUQ.asRandom_swigconstant(_tulipUQ)
asRandom = _tulipUQ.asRandom

_tulipUQ.asHalton_swigconstant(_tulipUQ)
asHalton = _tulipUQ.asHalton
class variableRecord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, variableRecord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, variableRecord, name)
    __repr__ = _swig_repr
    __swig_setmethods__["name"] = _tulipUQ.variableRecord_name_set
    __swig_getmethods__["name"] = _tulipUQ.variableRecord_name_get
    if _newclass:
        name = _swig_property(_tulipUQ.variableRecord_name_get, _tulipUQ.variableRecord_name_set)
    __swig_setmethods__["type"] = _tulipUQ.variableRecord_type_set
    __swig_getmethods__["type"] = _tulipUQ.variableRecord_type_get
    if _newclass:
        type = _swig_property(_tulipUQ.variableRecord_type_get, _tulipUQ.variableRecord_type_set)
    __swig_setmethods__["parameter1"] = _tulipUQ.variableRecord_parameter1_set
    __swig_getmethods__["parameter1"] = _tulipUQ.variableRecord_parameter1_get
    if _newclass:
        parameter1 = _swig_property(_tulipUQ.variableRecord_parameter1_get, _tulipUQ.variableRecord_parameter1_set)
    __swig_setmethods__["parameter2"] = _tulipUQ.variableRecord_parameter2_set
    __swig_getmethods__["parameter2"] = _tulipUQ.variableRecord_parameter2_get
    if _newclass:
        parameter2 = _swig_property(_tulipUQ.variableRecord_parameter2_get, _tulipUQ.variableRecord_parameter2_set)

    def __init__(self):
        this = _tulipUQ.new_variableRecord()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_variableRecord
    __del__ = lambda self: None
variableRecord_swigregister = _tulipUQ.variableRecord_swigregister
variableRecord_swigregister(variableRecord)
kExtractRandom = cvar.kExtractRandom
kExtractRandomWithInitialBuffer = cvar.kExtractRandomWithInitialBuffer
kExtractRandomWithFinalBuffer = cvar.kExtractRandomWithFinalBuffer
kExtractRandomWithBothEndsBuffer = cvar.kExtractRandomWithBothEndsBuffer
kExtractSequential = cvar.kExtractSequential
kSAMPLEUniform = cvar.kSAMPLEUniform
kSAMPLEGaussian = cvar.kSAMPLEGaussian
kSAMPLELognormal = cvar.kSAMPLELognormal
kSAMPLEConstant = cvar.kSAMPLEConstant
kRegular = cvar.kRegular
kCC = cvar.kCC
kDoubleCC = cvar.kDoubleCC
kBoundingBox = cvar.kBoundingBox
kFourSTD = cvar.kFourSTD

class inputSort(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, inputSort, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, inputSort, name)
    __repr__ = _swig_repr
    __swig_setmethods__["coord"] = _tulipUQ.inputSort_coord_set
    __swig_getmethods__["coord"] = _tulipUQ.inputSort_coord_get
    if _newclass:
        coord = _swig_property(_tulipUQ.inputSort_coord_get, _tulipUQ.inputSort_coord_set)
    __swig_setmethods__["idx"] = _tulipUQ.inputSort_idx_set
    __swig_getmethods__["idx"] = _tulipUQ.inputSort_idx_get
    if _newclass:
        idx = _swig_property(_tulipUQ.inputSort_idx_get, _tulipUQ.inputSort_idx_set)

    def __init__(self):
        this = _tulipUQ.new_inputSort()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_inputSort
    __del__ = lambda self: None
inputSort_swigregister = _tulipUQ.inputSort_swigregister
inputSort_swigregister(inputSort)

class by_idx(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, by_idx, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, by_idx, name)
    __repr__ = _swig_repr

    def __call__(self, a, b):
        return _tulipUQ.by_idx___call__(self, a, b)

    def __init__(self):
        this = _tulipUQ.new_by_idx()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_by_idx
    __del__ = lambda self: None
by_idx_swigregister = _tulipUQ.by_idx_swigregister
by_idx_swigregister(by_idx)

class uqSamples(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqSamples, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uqSamples, name)
    __repr__ = _swig_repr
    __swig_setmethods__["areIndependent"] = _tulipUQ.uqSamples_areIndependent_set
    __swig_getmethods__["areIndependent"] = _tulipUQ.uqSamples_areIndependent_get
    if _newclass:
        areIndependent = _swig_property(_tulipUQ.uqSamples_areIndependent_get, _tulipUQ.uqSamples_areIndependent_set)
    __swig_setmethods__["rvs"] = _tulipUQ.uqSamples_rvs_set
    __swig_getmethods__["rvs"] = _tulipUQ.uqSamples_rvs_get
    if _newclass:
        rvs = _swig_property(_tulipUQ.uqSamples_rvs_get, _tulipUQ.uqSamples_rvs_set)
    __swig_setmethods__["covCholFactor"] = _tulipUQ.uqSamples_covCholFactor_set
    __swig_getmethods__["covCholFactor"] = _tulipUQ.uqSamples_covCholFactor_get
    if _newclass:
        covCholFactor = _swig_property(_tulipUQ.uqSamples_covCholFactor_get, _tulipUQ.uqSamples_covCholFactor_set)
    __swig_setmethods__["corrCholFactor"] = _tulipUQ.uqSamples_corrCholFactor_set
    __swig_getmethods__["corrCholFactor"] = _tulipUQ.uqSamples_corrCholFactor_get
    if _newclass:
        corrCholFactor = _swig_property(_tulipUQ.uqSamples_corrCholFactor_get, _tulipUQ.uqSamples_corrCholFactor_set)

    def __init__(self, *args):
        this = _tulipUQ.new_uqSamples(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqSamples
    __del__ = lambda self: None

    def getTotSamples(self):
        return _tulipUQ.uqSamples_getTotSamples(self)

    def getTotDims(self):
        return _tulipUQ.uqSamples_getTotDims(self)

    def getValues(self, copyVals):
        return _tulipUQ.uqSamples_getValues(self, copyVals)

    def getValuesAt(self, sample, dim):
        return _tulipUQ.uqSamples_getValuesAt(self, sample, dim)

    def getCorrelatedValues(self, *args):
        return _tulipUQ.uqSamples_getCorrelatedValues(self, *args)

    def getWeights(self):
        return _tulipUQ.uqSamples_getWeights(self)

    def getWeightAt(self, nodeId, order):
        return _tulipUQ.uqSamples_getWeightAt(self, nodeId, order)

    def getMaxWeightOrder(self):
        return _tulipUQ.uqSamples_getMaxWeightOrder(self)

    def adjustWeights(self, maxOrder):
        return _tulipUQ.uqSamples_adjustWeights(self, maxOrder)

    def getTotRVS(self):
        return _tulipUQ.uqSamples_getTotRVS(self)

    def getRVS(self, index):
        return _tulipUQ.uqSamples_getRVS(self, index)

    def __call__(self, nRow, nCol):
        return _tulipUQ.uqSamples___call__(self, nRow, nCol)

    def setSampleIndependence(self, flag):
        return _tulipUQ.uqSamples_setSampleIndependence(self, flag)

    def addOneSample(self, sample):
        return _tulipUQ.uqSamples_addOneSample(self, sample)

    def buildFromMatrix(self, params):
        return _tulipUQ.uqSamples_buildFromMatrix(self, params)

    def addUniformSamplesFromPartition(self, samplesToAdd, limits):
        return _tulipUQ.uqSamples_addUniformSamplesFromPartition(self, samplesToAdd, limits)

    def addQuasiRandomSamplesFromPartition(self, samplesToAdd, type, onPartition, limits, rootLimits, startSampleIdx):
        return _tulipUQ.uqSamples_addQuasiRandomSamplesFromPartition(self, samplesToAdd, type, onPartition, limits, rootLimits, startSampleIdx)

    def normalizeColumns(self, symmetric):
        return _tulipUQ.uqSamples_normalizeColumns(self, symmetric)

    def addPointsOnBoundary(self, boundPointOrder):
        return _tulipUQ.uqSamples_addPointsOnBoundary(self, boundPointOrder)

    def denormalizeRV(self, value, dimId):
        return _tulipUQ.uqSamples_denormalizeRV(self, value, dimId)

    def rescaleOnHypercube(self, currLimits):
        return _tulipUQ.uqSamples_rescaleOnHypercube(self, currLimits)

    def rescaleFromHypercubeToPartition(self, currLimits):
        return _tulipUQ.uqSamples_rescaleFromHypercubeToPartition(self, currLimits)

    def addVariable(self, varName, varType, par1, par2):
        return _tulipUQ.uqSamples_addVariable(self, varName, varType, par1, par2)

    def addCovariance(self, covariance):
        return _tulipUQ.uqSamples_addCovariance(self, covariance)

    def areAllUniformVariables(self):
        return _tulipUQ.uqSamples_areAllUniformVariables(self)

    def correlateVariables(self):
        return _tulipUQ.uqSamples_correlateVariables(self)

    def decorrelateVariables(self):
        return _tulipUQ.uqSamples_decorrelateVariables(self)

    def generateRandomSamples(self, numSamples, seed=0):
        return _tulipUQ.uqSamples_generateRandomSamples(self, numSamples, seed)

    def generateSparseGrid(self, gridOrder):
        return _tulipUQ.uqSamples_generateSparseGrid(self, gridOrder)

    def generateCartesianGrid(self, gridOrder, gridType, rangeType):
        return _tulipUQ.uqSamples_generateCartesianGrid(self, gridOrder, gridType, rangeType)

    def readAndTransform(self, samples):
        return _tulipUQ.uqSamples_readAndTransform(self, samples)

    def extractSamples(self, size, extractionType, extractionTypeAux, indexes):
        return _tulipUQ.uqSamples_extractSamples(self, size, extractionType, extractionTypeAux, indexes)

    def extractSamplesWithIndex(self, indexes):
        return _tulipUQ.uqSamples_extractSamplesWithIndex(self, indexes)

    def extractSampleColumnWithIndex(self, Indexes, outCol, rhs):
        return _tulipUQ.uqSamples_extractSampleColumnWithIndex(self, Indexes, outCol, rhs)

    def extractPartitionSamples(self, samples, limits, ind):
        return _tulipUQ.uqSamples_extractPartitionSamples(self, samples, limits, ind)

    def extractSamplesWithOneOverlappingDimension(self, inputs, limits, dim, ind):
        return _tulipUQ.uqSamples_extractSamplesWithOneOverlappingDimension(self, inputs, limits, dim, ind)

    def extractOneDimensionalSamples(self, samples, dim):
        return _tulipUQ.uqSamples_extractOneDimensionalSamples(self, samples, dim)

    def evalNormalizedProbabilityOnHypercube(self, dim, location):
        return _tulipUQ.uqSamples_evalNormalizedProbabilityOnHypercube(self, dim, location)

    def readFromFile(self, outMatFile, skipFirstLine):
        return _tulipUQ.uqSamples_readFromFile(self, outMatFile, skipFirstLine)

    def readMCMCSubSamples(self, mcmcTraceFile, totSubSamples, startColumn, endColumn, sampleIndexes):
        return _tulipUQ.uqSamples_readMCMCSubSamples(self, mcmcTraceFile, totSubSamples, startColumn, endColumn, sampleIndexes)

    def readMCMCSubSamplesWithIndex(self, mcmcTraceFile, totSubSamples, sampleIndexes, startColumn, endColumn):
        return _tulipUQ.uqSamples_readMCMCSubSamplesWithIndex(self, mcmcTraceFile, totSubSamples, sampleIndexes, startColumn, endColumn)

    def printToFile(self, outMatFile, printTitle):
        return _tulipUQ.uqSamples_printToFile(self, outMatFile, printTitle)

    def printWeightsToFile(self, outMatFile, printTitle):
        return _tulipUQ.uqSamples_printWeightsToFile(self, outMatFile, printTitle)

    def addVariableFromFile(self, fileName, numColumn):
        return _tulipUQ.uqSamples_addVariableFromFile(self, fileName, numColumn)

    def getSampleLimits(self, *args):
        return _tulipUQ.uqSamples_getSampleLimits(self, *args)

    def evalDifference(self, refColumn):
        return _tulipUQ.uqSamples_evalDifference(self, refColumn)

    def removeFirstSamples(self, samplesToRemove):
        return _tulipUQ.uqSamples_removeFirstSamples(self, samplesToRemove)

    def addVariablesFromSample(self, qVals):
        return _tulipUQ.uqSamples_addVariablesFromSample(self, qVals)

    def removeVariable(self, idx):
        return _tulipUQ.uqSamples_removeVariable(self, idx)

    def addSamplesAdaptive(self, inputs, tree, metricThreshold, samplesInPartition, type=asRandom):
        return _tulipUQ.uqSamples_addSamplesAdaptive(self, inputs, tree, metricThreshold, samplesInPartition, type)

    def expTransform(self):
        return _tulipUQ.uqSamples_expTransform(self)

    def normalizeToOne(self):
        return _tulipUQ.uqSamples_normalizeToOne(self)

    def evalMultiVariateGaussian(self, mvg):
        return _tulipUQ.uqSamples_evalMultiVariateGaussian(self, mvg)

    def evalSamplePermutation(self, dim, samplePermutation):
        return _tulipUQ.uqSamples_evalSamplePermutation(self, dim, samplePermutation)

    def multiplyByScalar(self, scalars):
        return _tulipUQ.uqSamples_multiplyByScalar(self, scalars)
uqSamples_swigregister = _tulipUQ.uqSamples_swigregister
uqSamples_swigregister(uqSamples)

class uqException(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uqException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uqException, name)
    __repr__ = _swig_repr

    def __init__(self, m):
        this = _tulipUQ.new_uqException(m)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _tulipUQ.delete_uqException
    __del__ = lambda self: None

    def what(self):
        return _tulipUQ.uqException_what(self)
uqException_swigregister = _tulipUQ.uqException_swigregister
uqException_swigregister(uqException)


def convertTo01Array(intValue, numberOfDimension, resultVector):
    return _tulipUQ.convertTo01Array(intValue, numberOfDimension, resultVector)
convertTo01Array = _tulipUQ.convertTo01Array

def fft1DInv(size, gSize, GX, GY, fftWeights):
    return _tulipUQ.fft1DInv(size, gSize, GX, GY, fftWeights)
fft1DInv = _tulipUQ.fft1DInv

def solveDenseLinearSystem(totRows, totCols, coeffMat, currentRHS, sol):
    return _tulipUQ.solveDenseLinearSystem(totRows, totCols, coeffMat, currentRHS, sol)
solveDenseLinearSystem = _tulipUQ.solveDenseLinearSystem

def applyFourierSmoothing(numFreq, margY):
    return _tulipUQ.applyFourierSmoothing(numFreq, margY)
applyFourierSmoothing = _tulipUQ.applyFourierSmoothing

def convolutionWithGaussian(stdVal, margY):
    return _tulipUQ.convolutionWithGaussian(stdVal, margY)
convolutionWithGaussian = _tulipUQ.convolutionWithGaussian

def countLinesInFile(fileName):
    return _tulipUQ.countLinesInFile(fileName)
countLinesInFile = _tulipUQ.countLinesInFile
class stdVec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, stdVec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, stdVec, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _tulipUQ.stdVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tulipUQ.stdVec___nonzero__(self)

    def __bool__(self):
        return _tulipUQ.stdVec___bool__(self)

    def __len__(self):
        return _tulipUQ.stdVec___len__(self)

    def __getslice__(self, i, j):
        return _tulipUQ.stdVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tulipUQ.stdVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tulipUQ.stdVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tulipUQ.stdVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tulipUQ.stdVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tulipUQ.stdVec___setitem__(self, *args)

    def pop(self):
        return _tulipUQ.stdVec_pop(self)

    def append(self, x):
        return _tulipUQ.stdVec_append(self, x)

    def empty(self):
        return _tulipUQ.stdVec_empty(self)

    def size(self):
        return _tulipUQ.stdVec_size(self)

    def swap(self, v):
        return _tulipUQ.stdVec_swap(self, v)

    def begin(self):
        return _tulipUQ.stdVec_begin(self)

    def end(self):
        return _tulipUQ.stdVec_end(self)

    def rbegin(self):
        return _tulipUQ.stdVec_rbegin(self)

    def rend(self):
        return _tulipUQ.stdVec_rend(self)

    def clear(self):
        return _tulipUQ.stdVec_clear(self)

    def get_allocator(self):
        return _tulipUQ.stdVec_get_allocator(self)

    def pop_back(self):
        return _tulipUQ.stdVec_pop_back(self)

    def erase(self, *args):
        return _tulipUQ.stdVec_erase(self, *args)

    def __init__(self, *args):
        this = _tulipUQ.new_stdVec(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _tulipUQ.stdVec_push_back(self, x)

    def front(self):
        return _tulipUQ.stdVec_front(self)

    def back(self):
        return _tulipUQ.stdVec_back(self)

    def assign(self, n, x):
        return _tulipUQ.stdVec_assign(self, n, x)

    def resize(self, *args):
        return _tulipUQ.stdVec_resize(self, *args)

    def insert(self, *args):
        return _tulipUQ.stdVec_insert(self, *args)

    def reserve(self, n):
        return _tulipUQ.stdVec_reserve(self, n)

    def capacity(self):
        return _tulipUQ.stdVec_capacity(self)
    __swig_destroy__ = _tulipUQ.delete_stdVec
    __del__ = lambda self: None
stdVec_swigregister = _tulipUQ.stdVec_swigregister
stdVec_swigregister(stdVec)
kMathZero = cvar.kMathZero
kLegendreRange = cvar.kLegendreRange
kHaarRange = cvar.kHaarRange
kPolyMonomials = cvar.kPolyMonomials
kPolyLegendre = cvar.kPolyLegendre
kPolyHermite = cvar.kPolyHermite
kMIFullOrder = cvar.kMIFullOrder
kMIPartialOrder = cvar.kMIPartialOrder

class stdIntVec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, stdIntVec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, stdIntVec, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _tulipUQ.stdIntVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tulipUQ.stdIntVec___nonzero__(self)

    def __bool__(self):
        return _tulipUQ.stdIntVec___bool__(self)

    def __len__(self):
        return _tulipUQ.stdIntVec___len__(self)

    def __getslice__(self, i, j):
        return _tulipUQ.stdIntVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tulipUQ.stdIntVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tulipUQ.stdIntVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tulipUQ.stdIntVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tulipUQ.stdIntVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tulipUQ.stdIntVec___setitem__(self, *args)

    def pop(self):
        return _tulipUQ.stdIntVec_pop(self)

    def append(self, x):
        return _tulipUQ.stdIntVec_append(self, x)

    def empty(self):
        return _tulipUQ.stdIntVec_empty(self)

    def size(self):
        return _tulipUQ.stdIntVec_size(self)

    def swap(self, v):
        return _tulipUQ.stdIntVec_swap(self, v)

    def begin(self):
        return _tulipUQ.stdIntVec_begin(self)

    def end(self):
        return _tulipUQ.stdIntVec_end(self)

    def rbegin(self):
        return _tulipUQ.stdIntVec_rbegin(self)

    def rend(self):
        return _tulipUQ.stdIntVec_rend(self)

    def clear(self):
        return _tulipUQ.stdIntVec_clear(self)

    def get_allocator(self):
        return _tulipUQ.stdIntVec_get_allocator(self)

    def pop_back(self):
        return _tulipUQ.stdIntVec_pop_back(self)

    def erase(self, *args):
        return _tulipUQ.stdIntVec_erase(self, *args)

    def __init__(self, *args):
        this = _tulipUQ.new_stdIntVec(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _tulipUQ.stdIntVec_push_back(self, x)

    def front(self):
        return _tulipUQ.stdIntVec_front(self)

    def back(self):
        return _tulipUQ.stdIntVec_back(self)

    def assign(self, n, x):
        return _tulipUQ.stdIntVec_assign(self, n, x)

    def resize(self, *args):
        return _tulipUQ.stdIntVec_resize(self, *args)

    def insert(self, *args):
        return _tulipUQ.stdIntVec_insert(self, *args)

    def reserve(self, n):
        return _tulipUQ.stdIntVec_reserve(self, n)

    def capacity(self):
        return _tulipUQ.stdIntVec_capacity(self)
    __swig_destroy__ = _tulipUQ.delete_stdIntVec
    __del__ = lambda self: None
stdIntVec_swigregister = _tulipUQ.stdIntVec_swigregister
stdIntVec_swigregister(stdIntVec)

class stdMat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, stdMat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, stdMat, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _tulipUQ.stdMat_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tulipUQ.stdMat___nonzero__(self)

    def __bool__(self):
        return _tulipUQ.stdMat___bool__(self)

    def __len__(self):
        return _tulipUQ.stdMat___len__(self)

    def __getslice__(self, i, j):
        return _tulipUQ.stdMat___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tulipUQ.stdMat___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tulipUQ.stdMat___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tulipUQ.stdMat___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tulipUQ.stdMat___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tulipUQ.stdMat___setitem__(self, *args)

    def pop(self):
        return _tulipUQ.stdMat_pop(self)

    def append(self, x):
        return _tulipUQ.stdMat_append(self, x)

    def empty(self):
        return _tulipUQ.stdMat_empty(self)

    def size(self):
        return _tulipUQ.stdMat_size(self)

    def swap(self, v):
        return _tulipUQ.stdMat_swap(self, v)

    def begin(self):
        return _tulipUQ.stdMat_begin(self)

    def end(self):
        return _tulipUQ.stdMat_end(self)

    def rbegin(self):
        return _tulipUQ.stdMat_rbegin(self)

    def rend(self):
        return _tulipUQ.stdMat_rend(self)

    def clear(self):
        return _tulipUQ.stdMat_clear(self)

    def get_allocator(self):
        return _tulipUQ.stdMat_get_allocator(self)

    def pop_back(self):
        return _tulipUQ.stdMat_pop_back(self)

    def erase(self, *args):
        return _tulipUQ.stdMat_erase(self, *args)

    def __init__(self, *args):
        this = _tulipUQ.new_stdMat(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _tulipUQ.stdMat_push_back(self, x)

    def front(self):
        return _tulipUQ.stdMat_front(self)

    def back(self):
        return _tulipUQ.stdMat_back(self)

    def assign(self, n, x):
        return _tulipUQ.stdMat_assign(self, n, x)

    def resize(self, *args):
        return _tulipUQ.stdMat_resize(self, *args)

    def insert(self, *args):
        return _tulipUQ.stdMat_insert(self, *args)

    def reserve(self, n):
        return _tulipUQ.stdMat_reserve(self, n)

    def capacity(self):
        return _tulipUQ.stdMat_capacity(self)
    __swig_destroy__ = _tulipUQ.delete_stdMat
    __del__ = lambda self: None
stdMat_swigregister = _tulipUQ.stdMat_swigregister
stdMat_swigregister(stdMat)

class stdStringVec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, stdStringVec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, stdStringVec, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _tulipUQ.stdStringVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tulipUQ.stdStringVec___nonzero__(self)

    def __bool__(self):
        return _tulipUQ.stdStringVec___bool__(self)

    def __len__(self):
        return _tulipUQ.stdStringVec___len__(self)

    def __getslice__(self, i, j):
        return _tulipUQ.stdStringVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tulipUQ.stdStringVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tulipUQ.stdStringVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tulipUQ.stdStringVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tulipUQ.stdStringVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tulipUQ.stdStringVec___setitem__(self, *args)

    def pop(self):
        return _tulipUQ.stdStringVec_pop(self)

    def append(self, x):
        return _tulipUQ.stdStringVec_append(self, x)

    def empty(self):
        return _tulipUQ.stdStringVec_empty(self)

    def size(self):
        return _tulipUQ.stdStringVec_size(self)

    def swap(self, v):
        return _tulipUQ.stdStringVec_swap(self, v)

    def begin(self):
        return _tulipUQ.stdStringVec_begin(self)

    def end(self):
        return _tulipUQ.stdStringVec_end(self)

    def rbegin(self):
        return _tulipUQ.stdStringVec_rbegin(self)

    def rend(self):
        return _tulipUQ.stdStringVec_rend(self)

    def clear(self):
        return _tulipUQ.stdStringVec_clear(self)

    def get_allocator(self):
        return _tulipUQ.stdStringVec_get_allocator(self)

    def pop_back(self):
        return _tulipUQ.stdStringVec_pop_back(self)

    def erase(self, *args):
        return _tulipUQ.stdStringVec_erase(self, *args)

    def __init__(self, *args):
        this = _tulipUQ.new_stdStringVec(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _tulipUQ.stdStringVec_push_back(self, x)

    def front(self):
        return _tulipUQ.stdStringVec_front(self)

    def back(self):
        return _tulipUQ.stdStringVec_back(self)

    def assign(self, n, x):
        return _tulipUQ.stdStringVec_assign(self, n, x)

    def resize(self, *args):
        return _tulipUQ.stdStringVec_resize(self, *args)

    def insert(self, *args):
        return _tulipUQ.stdStringVec_insert(self, *args)

    def reserve(self, n):
        return _tulipUQ.stdStringVec_reserve(self, n)

    def capacity(self):
        return _tulipUQ.stdStringVec_capacity(self)
    __swig_destroy__ = _tulipUQ.delete_stdStringVec
    __del__ = lambda self: None
stdStringVec_swigregister = _tulipUQ.stdStringVec_swigregister
stdStringVec_swigregister(stdStringVec)

class stdStringMat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, stdStringMat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, stdStringMat, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _tulipUQ.stdStringMat_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _tulipUQ.stdStringMat___nonzero__(self)

    def __bool__(self):
        return _tulipUQ.stdStringMat___bool__(self)

    def __len__(self):
        return _tulipUQ.stdStringMat___len__(self)

    def __getslice__(self, i, j):
        return _tulipUQ.stdStringMat___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _tulipUQ.stdStringMat___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _tulipUQ.stdStringMat___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _tulipUQ.stdStringMat___delitem__(self, *args)

    def __getitem__(self, *args):
        return _tulipUQ.stdStringMat___getitem__(self, *args)

    def __setitem__(self, *args):
        return _tulipUQ.stdStringMat___setitem__(self, *args)

    def pop(self):
        return _tulipUQ.stdStringMat_pop(self)

    def append(self, x):
        return _tulipUQ.stdStringMat_append(self, x)

    def empty(self):
        return _tulipUQ.stdStringMat_empty(self)

    def size(self):
        return _tulipUQ.stdStringMat_size(self)

    def swap(self, v):
        return _tulipUQ.stdStringMat_swap(self, v)

    def begin(self):
        return _tulipUQ.stdStringMat_begin(self)

    def end(self):
        return _tulipUQ.stdStringMat_end(self)

    def rbegin(self):
        return _tulipUQ.stdStringMat_rbegin(self)

    def rend(self):
        return _tulipUQ.stdStringMat_rend(self)

    def clear(self):
        return _tulipUQ.stdStringMat_clear(self)

    def get_allocator(self):
        return _tulipUQ.stdStringMat_get_allocator(self)

    def pop_back(self):
        return _tulipUQ.stdStringMat_pop_back(self)

    def erase(self, *args):
        return _tulipUQ.stdStringMat_erase(self, *args)

    def __init__(self, *args):
        this = _tulipUQ.new_stdStringMat(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _tulipUQ.stdStringMat_push_back(self, x)

    def front(self):
        return _tulipUQ.stdStringMat_front(self)

    def back(self):
        return _tulipUQ.stdStringMat_back(self)

    def assign(self, n, x):
        return _tulipUQ.stdStringMat_assign(self, n, x)

    def resize(self, *args):
        return _tulipUQ.stdStringMat_resize(self, *args)

    def insert(self, *args):
        return _tulipUQ.stdStringMat_insert(self, *args)

    def reserve(self, n):
        return _tulipUQ.stdStringMat_reserve(self, n)

    def capacity(self):
        return _tulipUQ.stdStringMat_capacity(self)
    __swig_destroy__ = _tulipUQ.delete_stdStringMat
    __del__ = lambda self: None
stdStringMat_swigregister = _tulipUQ.stdStringMat_swigregister
stdStringMat_swigregister(stdStringMat)

# This file is compatible with both classic and new-style classes.


